## 20230321
### 基本运算
有符号数右移是补符号

截断与扩展
有无符号数

浮点数和整数计算是分开的，有专用的浮点数寄存器，连续两个寄存器存放一个高精度。

Ty 平均传输延迟时间

C语言指令 汇编（MIPS）指令
MIPS能支撑高级语言需求

### ALU 实现
延迟计算 与或1ty 异或3ty
carryout = B&Carry | A&Carry | A&B 2ty
sum = A xor B xor Carry                    6ty

###### 串行进位加法器 *Ripple-carry Adder*
carryout and sum
Delay(n bits)延迟：c0-cn carry 2n    最后一位和数 2(n-1)+3
$t_{ripple}=Nt_{fulladder}$

###### 并行进位加法器 *Carry Look Ahead*
![[Screenshot 2023-05-10 at 10.51.34.png]]
G *Generate* P *Propagate*
$G_i =  A_i \oplus B_i$ 进位传递函数
$P_i=A_iB_i$ 进位生成函数
then
$S_i=P_i\oplus C_i$ 奇数个为1
$C_{i+1}=P_iC_i+G_i$ 两种要进位的情况
$$Ci = A_iB_i +(A_i + B_i)C{i–1} = G_i +P_iC_{i–1}$$
$$G_{3:0}=G_3+P_3(G_2+P_2(G_1+P_1G_0))$$
$$ P_{3:0}=P_3P_2P_1P_0$$
CLA carry look ahead 先行进位
CLA加法器由“进位生成/传递部件”、“CLA部件”和“求和部件”构成
进位可根据前面几位的真值用组合逻辑直接算出
各个进位独立同时产生
$$t_{cla}=t_{pg}+t_{pgblock}+(\frac{N}{k}-1)(and+or)+k*t_{fulladder}$$

> 对于前级CLA Block，要尽快生成最高位的进位，于是就有了进位生成和传递部件
> 但其实也重复计算了block内的进位，全加器和进位传递部分都有有一定重复
> 最后空间、gate数量会比ripple-carry高

###### 全先行进位加法器
8bit 和的总延迟：3(进位生成部件,算P)+2(CLA算carry的部件)+3(xor)=8ty   进位c8延迟：3+2=5ty

###### 局部先行进位加法器
“组内并行、组间串行”
partial carry lookahead adder PCL 单级先行进位加法器
实现一个全先行进位加法器成本太高，通常是用多个位数较少的全先行仅为加法器串联。
4个8bit全先行加法串联为32bit,所有合数产生延迟 3+2+2+5 = 12ty 
![[Pasted image 20230611153652.png]]
>此处延迟计算存疑 有说法是14ty

###### 多级先行进位加法器
“组内并行、组间并行” 引入组进位生成传递函数
设n=4,则：
$C1=G0+P0C0$　　　　 　         
$C2=G1+P1C1=G1+P1G0+P1P0C0$
$C3=G2+P2C2=G2+P2G1+P2P1G0+P2P1P0C0$
$C4=G3+P3C3=G3+P3G2+P3P2G1+P3P2P1G0+P3P2P1P0C0$
设
$G3*=G3+P3C3=G3+P3G2+P3P2G1+P3P2P1G0$
$P3*=P3P2P1P0$
把实现上述逻辑的电路称为4位BCLA部件。
组进位$C_4 =G_3^*+P_3^*C_0$。
BCLA部件：一种快速计算多个小CLA单元的进位的部件。快速算出组进位![[Pasted image 20230611153643.png]]
>此处不熟 https://blog.csdn.net/LHYzyp/article/details/73831207

###### Prefix Adder
[[Chapter 5 Digital Building Blocks]]

#### ALU *Arithmetic Logic Unit*
标志位的产生
NZ 显然
C：ALU有Carry且在执行加减法
V：在执行加减法，且是正数加正数或负数加负数，且结果的符号与第一个数不同

## 20230323 定点数运算方式

### 加减

###### 补码加减运算
直接实现 溢出判断，两种方式（OF=C_n xor C_{n-1) , 和的符号位和加数的符号位不同）
双符号位溢出判断：正溢出负溢出正负无溢出 四种情况

###### 原码加减运算
用于浮点数尾数，符号与数值分开，符号起控制作用（判断尾数间该求和还是差）。求差先求补。

求差 a-b b-a 可能正可能负 结果又要判断
先加上补码
- 最高位有进位 则说明减法无借位 是大的减小的 符号为被减数的符号
- 最高位无进位 说明减法有借位 要对结果求补 符号与被减数的符号相反

**为什么加补码的最高位有进位就说明对应减法无借位**
因为CF=Cout xor SUB
SUB == 1(因为是减法运算)
Cout是进位
![[20230401-150149.jpg]]


###### 移码加减运算
用于浮点数阶码 针对标准移码，移码的和差等于和差的补码
[E1]移+[E2]移=$2^{n-1}+E1+2^{n-1}+E2=2^n+E1+E2$=[E1+E2]补 （mod 2n）
由补码和标准移码的关系可得和/差的移码：符号位取反、数值位相同。
对于标准移码，（减法要先对减数求补（取反后加一）），进行模$2^n$加，对结果**符号**取反

标准移码 在补码加减法器的符号为*MSB*加一个反相器

### 乘法
用到左移和加法 可以用ALU+移位器实现乘法运算
二进制竖式
计算机对手算的改进：及时求和（每步求和），结果右移后与新结果相加（不是想左算），只对乘数中“1”位执行加法，0位仅右移

符号与数值分开处理：积符由异或得到，数值用无符号乘法运算

原码一位乘法：每次只取乘数的一位判断，需n次循环，速度慢。
原码两位乘法：每次取乘数两位判断，只需n/2次循环，快一倍。

### 除法
异或？你倒是举点例子啊
乘法和除法运算的硬件相同，仅需做加、减和64位寄存器的左/右移位

### 定点运算器
所有运算都可通过“加”和“移位”操作实现
运算部件通常指ALU、移位器、寄存器组，加上用于数据选择的多路选择器和实现数据传送的总线等构成的一个运算数据通路。


## 20230328 浮点数运算方式
$x\pm y=(M_x\pm M_y\times 2^{-(E_x-E_y)})\times 2^{E_x}$
$x\times y=(M_x\times M_y)\times 2^{E_x+E_y}$
$x/y=(M_x/M_y)\times 2^{E_x-E_y}$
where $x=M_x \times 2^{E_x}$ and $y=M_y \times 2^{E_y}$, and it is assumed that $E_x\geq E_y$.

运算移位时可能损失一些位，于是添加一些附加位。
> 保护位（guard bit）和舍入位（rounding bit）为了使浮点数的有效数据位在右移时最大限度地保证不丢失，一般在运算过程中得到的中间值后面增加若干数据位，这些位用来保存右移后的有效数据，因此，是添加的附加位。增设附加位后，能保证运算结果具有一定的精度，但最终必须将附加位去掉，以得到规定格式的浮点数，此时要考虑舍入。在 IEEE 754 标准中规定，浮点运算的中间结果可以额外多保留两位附加位，这两位分别称为保护位和舍入位。 粘位（sticky bit）IEEE 754 标准中规定，为了更进一步提高计算精度，可以在舍入位右边再增加一位，称为「粘位」，只要舍入位的右边还有任何非零数位，则粘位为 1，否则为 0。[Source](https://fumeboy.github.io/ComputerOrganization/Chapter2/3.html)

附加位舍入方法有四种：***就近、朝$-\infty,\infty,0截取$***

###### 浮点数加减
- 计算两者阶差（阶码减法）
- 对阶 移位 保留附加位
- 尾数加减
- 规范化 规范成浮点数规范表示 根据阶码是否上下溢判断是否溢出（尾数左移阶码减，尾数右移阶码加***阶码加减一运算***）
- 考虑舍入
- 尾数0，阶码也0 （说明结果为0）

***阶码加减一运算***
主要是减一，加法就直接加
减一？+[-1]补 = + 11…1  （255）
[Z-1]移=127+Z-1=Z移-1=Z移+[-1]补

###### 浮点数乘除
- 求阶 阶码加减运算
- 尾数采用原码乘除运算
- 符号判断，xor
- 规范化 乘法只会右归 最多一次 除法反之
- 尾数舍入
- 0判断 类似加减法
- 阶码溢出判断

浮点数，8bit，阶码（移码）偏移量127
【E1+E2】移 = 【E1】移+【E2】移 + 【-127】补(也就是1 0 0 0 0 0 0 1 )  最后mod $2^8$
减法 加127（偏移量在减法中抵消去掉了，结果也要是移码，故要加回去） 最后mod $2^8$
127=01111111 减一个移码等于加移码的补码，即加上该移码按位取反再加一的值